(function ($) {                                          // Compliant with jquery.noConflict()
    $.fn.jCarouselLite = function (o) {
        o = $.extend({
            btnPrev: null,
            btnNext: null,
            btnGo: null,
            mouseWheel: false,
            auto: null,

            speed: 200,
            easing: null,

            vertical: false,
            circular: true,
            visible: 3,
            start: 0,
            scroll: 1,
            resultSetLength: 3,

            beforeStart: null,
            afterEnd: null
        }, o || {});

        return this.each(function () {                           // Returns the element collection. Chainable.

            var running = false, animCss = o.vertical ? "top" : "left", sizeCss = o.vertical ? "height" : "width";
            var div = $(this), ul = $("ul", div), tLi = $("li", ul), tl = tLi.size(), v = o.visible;

            // Patch to fix the problem with the vertical scroll by Alex (it is a fix to the patch that was made to the control originally bc it doesnt support the desired functionality) case 44311
            var tempv = o.vertical ? 3 : v; // if vertical o.visible = 1 (patch to use it on comm results) so set it to 3 that is the size of the visible items

            if (o.circular && tl > tempv) { // execute the circular logic only if there are items to scroll
                // if it is vertical and the number of items is not exact to the scroll page size, add empty items to fill the page size so it works as normally
                if (o.vertical) {
                    var gap = 3 - (tl % 3), emptyLi = tLi.slice(tl - 1).clone().empty(), i = 0; // compute how many items need to fit the scroll page size, and initialize the empty item based on an existing il item

                    // add the empty il elements to fit the scroll page size
                    for (i = 0; i < gap && gap != 3; i++) {
                        ul.append(emptyLi.css('visibility', 'hidden').clone());
                    }

                    tLi = $("li", ul); tl = tLi.size(); // recompute the list size
                }

                // execute the same logic (duplicate the last N visible items in the begining and the first N visible items in the end to emulate the infinite effect
                ul.prepend(tLi.slice(tl - tempv).clone()).append(tLi.slice(0, tempv).clone());
                o.start += tempv;
            }

            div.hover(function () {
                div.hovered = true;
            }, function () {
                div.hovered = false;
            });

            var li = $("li", ul), itemLength = o.vertical ? li.size() / o.resultSetLength : li.size(), curr = o.start;
            div.css("visibility", "visible");

            li.css({ overflow: "hidden", float: "left" });
            ul.css({ margin: "0", padding: "0", position: "relative", "list-style-type": "none", "z-index": "1" });
            div.css({ overflow: "hidden", position: "relative", "z-index": "2", left: "0px" });

            var liSize = o.vertical ? height(li) : width(li);   // Full li size(incl margin)-Used for animation
            var ulSize = liSize * itemLength + 40;                   // size of full ul(total length, not just for the visible items)
            var divSize = liSize * v;                           // size of entire div(total length for just the visible items)

            li.css({ width: li.width(), height: li.height() });
            ul.css(sizeCss, ulSize + "px").css(animCss, -(curr * liSize));

            div.css(sizeCss, divSize + "px");                     // Width of the DIV. length of visible images

            if (o.btnPrev)
                $(o.btnPrev).click(function () {
                    div.navigated = true;
                    return go(curr - o.scroll);
                });

            if (o.btnNext)
                $(o.btnNext).click(function () {
                    div.navigated = true;
                    return go(curr + o.scroll);
                });

            if (o.btnGo)
                $.each(o.btnGo, function (i, val) {
                    $(val).click(function () {
                        div.navigated = true;
                        return go(o.circular ? o.visible + i : i);
                    });
                });

            if (o.mouseWheel && div.mousewheel)
                div.mousewheel(function (e, d) {
                    return d > 0 ? go(curr - o.scroll) : go(curr + o.scroll);
                });

            if (o.auto && tl > tempv) // execute the auto start logic only if there are items to scroll
                setInterval(function () {
                    if (!div.hovered)
                        go(curr + o.scroll);
                }, o.auto + o.speed);

            function vis() {
                return li.slice(curr).slice(0, v);
            };

            function go(to) {
                if (!running) {

                    if (o.beforeStart)
                        o.beforeStart.call(this, vis());

                    if (o.circular) {            // If circular we are in first or last, then goto the other end

                        if (to <= o.start - v - 1) {           // If first, then goto last
                            ul.css(animCss, -((itemLength - (v * 2)) * liSize) + "px");
                            // If "scroll" > 1, then the "to" might not be equal to the condition; it can be lesser depending on the number of elements.
                            curr = to == o.start - v - 1 ? itemLength - (v * 2) - 1 : itemLength - (v * 2) - o.scroll;
                        } else if (to >= itemLength - v + 1) { // If last, then goto first
                            ul.css(animCss, -((v) * liSize) + "px");
                            // If "scroll" > 1, then the "to" might not be equal to the condition; it can be greater depending on the number of elements.
                            curr = to == itemLength - v + 1 ? v + 1 : v + o.scroll;
                        } else curr = to;
                    } else {                    // If non-circular and to points to first or last, we just return.
                        if (to < 0 || to > itemLength - v) return;
                        else curr = to;
                    }                           // If neither overrides it, the curr will still be "to" and we can proceed.

                    running = true;

                    ul.animate(
                    animCss == "left" ? { left: -(curr * liSize)} : { top: -(curr * liSize) }, o.speed, o.easing,
                    function () {
                        if (o.afterEnd)
                            o.afterEnd.call(this, vis());
                        running = false;
                    }
                );
                    // Disable buttons when the carousel reaches the last/first, and enable when not
                    if (!o.circular) {
                        $(o.btnPrev).removeClass("carousel-prev-disabled");
                        $(o.btnNext).removeClass("carousel-next-disabled");
                        if (curr - o.scroll < 0) $(o.btnPrev).addClass("carousel-prev-disabled");
                        if (curr + o.scroll > itemLength - v) $(o.btnNext).addClass("carousel-next-disabled");
                    }

                }
                return false;
            };
        });
    };

    function css(el, prop) {
        return parseInt($.css(el[0], prop)) || 0;
    };
    function width(el) {
        return el[0].offsetWidth + css(el, 'marginLeft') + css(el, 'marginRight');
    };
    function height(el) {
        return el[0].offsetHeight + css(el, 'marginTop') + css(el, 'marginBottom');
    };

})(jQuery);